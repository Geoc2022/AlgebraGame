msgid ""
msgstr "Project-Id-Version: Game v4.23.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-10\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#. ยง0: ```
#. induction l with
#. | nil => ...
#. | cons fst rst => ...
#. ```
#. ยง1: `l`
#. ยง2: `fst`
#. ยง3: `rst`
#: Game.Levels.Group.L06_CombinedInv2
msgid "ยง0\n"
"is a tactic that performs induction on the list ยง1, with the first element of the list being called ยง2 and the rest of the list being called ยง3."
msgstr ""

#. ยง0: `oneFunction G H g = 1`
#. ยง1: `g โ G`
#. ยง2: `G`
#. ยง3: `H`
#: Game.Levels.GroupHom.L04_OneHom
msgid "Let's check out another example of a homomorphism. Instead of sending elements to themselves let's send them to the trivial group (the group with only the identity). This is called the trivial homomorphism.\n"
"\n"
"  We will denote the trivial homomorphism by oneFunction. It is defined by ยง0 for all ยง1, where the function maps the group ยง2 to the group ยง3."
msgstr ""

#. ยง0: `one_mul`
#. ยง1: `m : M`
#. ยง2: `m * 1 = m`
#: Game.Levels.Monoid.L01_MulLeft
#: Game.Levels.Group.L01_MulInv
msgid "ยง0 is a proof that for all ยง1, ยง2 (Right Identity Axiom)."
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! ๐"
msgstr ""

#. ยง0: `inv_anticomm`
#. ยง1: `g * h`
#: Game.Levels.Group.L05_CombinedInv
msgid "ยง0 is a proof that there exists a inverse of ยง1 in a group."
msgstr ""

#: Game.Levels.PowGroup
msgid "Group Power World"
msgstr ""

#. ยง0: `m`
#. ยง1: `mยน = m`
#: Game.Levels.PowMonoid.L01_PowOne
msgid "If ยง0 is an element of a monoid, then ยง1."
msgstr ""

#. ยง0: `repeat t`
#. ยง1: `t`
#: Game.Levels.Monoid.L01_MulLeft
msgid "ยง0 repeatedly applies the tactic ยง1 to the goal. You don't need to use thistactic, it just speeds things up sometimes."
msgstr ""

#. ยง0: `ฮป`
#. ยง1: `โ`
#: Game.Levels.GroupHom.L05_HomCompHom
msgid "Use ยง0 notation and/or ยง1 (written \"\\\\circ\") to construct functions"
msgstr ""

#: Game.Levels.Monoid.L02_MulRight
msgid "Right Multiplication"
msgstr ""

#: Game.Levels.Monoid.L02_MulRight
msgid "Here's a dual of that last level."
msgstr ""

#. ยง0: `match`
#: Game.Levels.PowGroup.L01_PowNegNat
msgid "The ยง0 tactic performs pattern matching on an expression."
msgstr ""

#. ยง0: `g * h`
#: Game.Levels.Group.L05_CombinedInv
msgid "Congrats! Can we say more about the inverse of ยง0? Maybe using the last level we can answer \"Is it unique?\""
msgstr ""

#. ยง0: `MyAlgebra.gpow_ofNat`
#. ยง1: `g ^ (n : โค) = g ^ n`
#: Game.Levels.PowGroup.L01_PowNegNat
msgid "ยง0 is a proof that ยง1 (natural power)."
msgstr ""

#. ยง0: `sr i`
#. ยง1: `D_n`
#. ยง2: `i`
#. ยง3: `n`
#: Game.Levels.GroupExamples.L01_Z_mod_mZ_Id
msgid "ยง0 represents a reflection element in the dihedral group ยง1, where ยง2 is an integer modulo ยง3."
msgstr ""

#: Game.Levels.Group.L02_CancelLeft
msgid "We now prove that we can cancel left multiplication. This is a nice helper lemma to work with groups."
msgstr ""

#. ยง0: `m`
#. ยง1: `x`
#. ยง2: `y`
#. ยง3: `m ^ (x * y) = (m ^ x) ^ y`
#: Game.Levels.PowMonoid.L04_PowMul
msgid "For any ยง0 in a monoid and naturals ยง1, ยง2, ยง3."
msgstr ""

#. ยง0: `m ^ (n+1) = m ^ n * m`
#. ยง1: `m ^ (n+1) = m * m ^ n`
#: Game.Levels.PowMonoid.L02_PowSuccLeft
msgid "We know that ยง0. In this level\n"
"you will show the equivalent statement with multiplication on the left:\n"
"ยง1."
msgstr ""

#. ยง0: `id x`
#. ยง1: `x`
#: Game.Levels.GroupHom.L01_HomPreservesOne
msgid "ยง0 is the identity function, which returns ยง1 itself."
msgstr ""

#. ยง0: `mul_assoc`
#. ยง1: `m1 m2 m3 : M`
#. ยง2: `(m1 * m2) * m3 = m1 * (m2 * m3)`
#: Game.Levels.Monoid.L01_MulLeft
#: Game.Levels.Group.L01_MulInv
msgid "ยง0 is a proof that for all ยง1, ยง2 (Associative Law)."
msgstr ""

#. ยง0: `m ^ x * m ^ y = m ^ y * m ^ x`
#. ยง1: `m^x`
#. ยง2: `m`
#: Game.Levels.PowMonoid.L07_PowCommPow
msgid "Finally, you will prove the full statement:\n"
"ยง0. We already know ยง1 commutes with ยง2,\n"
"so we use induction to extend this to all powers."
msgstr ""

#. ยง0: `1 ^ x = 1`
#: Game.Levels.PowMonoid.L05_PowId
msgid "Now show that the identity element is fixed under taking powers:\n"
"ยง0."
msgstr ""

#. ยง0: `inv_unique`
#: Game.Levels.Group.L04_InvUnique
msgid "ยง0 is a proof that there is only one inverse element in a group for any given element."
msgstr ""

#: Game.Levels.PowGroup.L08_PowMul
msgid "Excellent! Youโve proved the full multiplication law for integer exponents."
msgstr ""

#. ยง0: `Int.negSucc n`
#. ยง1: `-(n + 1)`
#: Game.Levels.PowGroup.L01_PowNegNat
msgid "ยง0 represents the integer ยง1."
msgstr ""

#. ยง0: `hom_preserves_one`
#: Game.Levels.GroupHom.L01_HomPreservesOne
msgid "ยง0 is a proof that a homomorphism preserves the identity element."
msgstr ""

#: Game
msgid "Introduction to basic algebra"
msgstr ""

#. ยง0: `mul_left_cancel`
#. ยง1: `h * g1 = h * g2`
#. ยง2: `g1 = g2`
#. ยง3: `mul_left`
#: Game.Levels.Group.L02_CancelLeft
#: Game.Levels.Group.L03_CancelRight
msgid "ยง0 is a proof that if ยง1, then ยง2 - the inverse of ยง3 is a function."
msgstr ""

#: Game.Levels.Group.L01_MulInv
msgid "Right Multiplicative Inverse"
msgstr ""

#. ยง0: `m`
#. ยง1: `m ^ x * m = m * m ^ x`
#: Game.Levels.PowMonoid.L06_PowCommMul
msgid "In a general monoid, ยง0 need not commute with all elements, but\n"
"it does commute with its own powers. Youโll prove ยง1."
msgstr ""

#. ยง0: `h`
#. ยง1: `X = Y`
#. ยง2: `rw [h]`
#. ยง3: `X`
#. ยง4: `Y`
#: Game.Levels.Monoid.L01_MulLeft
msgid "If ยง0 is a proof of an equality ยง1, then ยง2 will change\n"
"all ยง3s in the goal to ยง4s. It's the way to \\\\\"substitute in\\\\\"."
msgstr ""

#: Game.Levels.GroupExamples.L01_Z_mod_mZ_Id
msgid "Z mod mZ Identity"
msgstr ""

#. ยง0: `m ^ (n+1) = m ^ n * m`
#. ยง1: `m ^ 0 = 1`
#: Game.Levels.PowMonoid.L01_PowOne
msgid "Recall the definition: ยง0 and ยง1."
msgstr ""

#: Game.Levels.PowGroup.L01_PowNegNat
msgid "Great! Youโve connected negative integer exponents with inverses of natural powers."
msgstr ""

#. ยง0: `1 * 1 = 1`
#: Game.Levels.PowMonoid.L05_PowId
msgid "Use the recursive definition of pow and the fact that ยง0."
msgstr ""

#. ยง0: `inv_inj`
#: Game.Levels.Group.L09_InvInj
msgid "ยง0 is a proof that the inverse is injective."
msgstr ""

#. ยง0: `ZMod n`
#. ยง1: `n`
#: Game.Levels.GroupExamples.L01_Z_mod_mZ_Id
msgid "ยง0 is the type of integers modulo ยง1."
msgstr ""

#: Game
msgid "# Welcome to the Algebra Game\n"
"#### An introduction to algebraic structures.\n"
"\n"
"In this game, we will build the basic theory of Groups, Rings, and Fields from scratch. We'll do this by solving levels of a computer puzzle game called Lean.\n"
"\n"
"It's recommend that you play the [Natural Number Game](https://adam.math.hhu.de/#/g/leanprover-community/NNG4) to learn the basics of Lean before playing this game."
msgstr ""

#: Game.Levels.PowGroup.L07_PowSub
msgid "Nice! Youโve shown that a negative exponent in the second factor corresponds to subtracting exponents."
msgstr ""

#. ยง0: `GroupHom`
#. ยง1: `GroupHom`
#. ยง2: `use`
#. ยง3: `x โ โค`
#. ยง4: `โ n : โค, x + n = n`
#. ยง5: `use 0`
#. ยง6: `0 + n = n`
#. ยง7: `GroupHom`
#. ยง8: `use`
#. ยง9: `ฮป`
#. ยง10: `ฮป x y, x + y`
#. ยง11: `x, y`
#. ยง12: `x + y`
#. ยง13: `f โ g`
#. ยง14: `x`
#. ยง15: `f (g x)`
#: Game.Levels.GroupHom.L05_HomCompHom
msgid "We have seen that the identity function is a homomorphism. Now we will see that the composition of two homomorphisms is also a homomorphism.\n"
"\n"
"  ยง0 is defined as a structure with a proof that the function is a homomorphism, and the function itself. To create a new ยง1 instance, we need to provide the function and the proof.\n"
"\n"
"  We can use the ยง2 tactic to prove the existence of a type using construction. For example to prove that there is a number ยง3 such that ยง4 you can write ยง5 which will replace the goal with ยง6. In this case, you might want to use it to create a new ยง7 instance. The tactic ยง8 takes a function as an argument, and then asks us to prove that the function is a homomorphism.\n"
"\n"
"  Furthermore, you can construct functions using ยง9 notation and โ (written \"\\\\circ\"). For example, ยง10 is the function that takes ยง11 to ยง12. And ยง13 is the function that takes ยง14 to ยง15."
msgstr ""

#: Game.Levels.Monoid.L03_OneUnique
msgid "We know from monoid axioms that there exists an identity element, but is it unique? One approach to proving this is to have two \"different\" identities that we see are actually the same."
msgstr ""

#: Game.Levels.GroupHom.L03_IdHom
msgid "Let's check out an example of a homomorphism. Here's a simple one: the identity function."
msgstr ""

#. ยง0: `+`
#. ยง1: `*`
#. ยง2: `+`
#. ยง3: `0 โ R`
#. ยง4: `r โ R`
#. ยง5: `s โ R`
#. ยง6: `r1, r2, r3 โ R`
#. ยง7: `r1, r2 โ R`
#. ยง8: `*`
#. ยง9: `1 โ R`
#. ยง10: `r1, r2, r3 โ R`
#. ยง11: `+`
#. ยง12: `*`
#. ยง13: `r1, r2, r3 โ R`
#. ยง14: `r1, r2, r3 โ R`
#: Game.Levels.Ring
msgid "A ring is a set R together with two binary operations ยง0 and ยง1 satisfying the following axioms:\n"
"\n"
"  ### The set R together with the binary operation ยง2 is an abelian group with identity element 0.\n"
"\n"
"  #### Additive Identity Axiom\n"
"   There is an element ยง3 such that\n"
"\n"
"    - add_zero : โ r : R, 0 + r = r\n"
"    - zero_add : โ r : R, r + 0 = r\n"
"\n"
"  #### Additive Inverse Axiom\n"
"   For every ยง4 there is an element ยง5 such that\n"
"\n"
"    - add_neg : โ r : R, r + (-r) = 0\n"
"    - neg_add : โ r : R, (-r) + r = 0\n"
"\n"
"  #### Additive Associative Law\n"
"   For all ยง6, the associative law holds:\n"
"\n"
"    - add_assoc : โ r1 r2 r3 : R, (r1 + r2) + r3 = r1 + (r2 + r3)\n"
"\n"
"  #### Additive Commutative Law\n"
"   For all ยง7, the commutative law holds:\n"
"\n"
"    - add_comm : โ r1 r2 : R, r1 + r2 = r2 + r1\n"
"\n"
"  ### The set R together with the binary operation ยง8 is a monoid with identity element 1.\n"
"\n"
"  #### Multiplicative Identity Axiom\n"
"   There is an element ยง9 such that\n"
"\n"
"    - one_mul : โ r : R, 1 * r = r\n"
"    - mul_one : โ r : R, r * 1 = r\n"
"\n"
"  #### Multiplicative Associative Law\n"
"   For all ยง10, the associative law holds:\n"
"\n"
"    - mul_assoc : โ r1 r2 r3 : R, (r1 * r2) * r3 = r1 * (r2 * r3)\n"
"\n"
"  ### The two binary operations ยง11 and ยง12 satisfy the following distributive laws:\n"
"\n"
"  #### Left Distributive Law\n"
"   For all ยง13, the left distributive law holds:\n"
"\n"
"    - distrib_right : โ r1 r2 r3 : R, (r1 + r2) * r3 = (r1 * r3) + (r2 * r3)\n"
"\n"
"  #### Right Distributive Law\n"
"   For all ยง14, the right distributive law holds:\n"
"\n"
"    - distrib_left : โ r1 r2 r3 : R, r1 * (r2 + r3) = (r1 * r2) + (r1 * r3)"
msgstr ""

#. ยง0: `mul_inv`
#. ยง1: `g : G`
#. ยง2: `g * gโปยน = 1`
#: Game.Levels.Group.L01_MulInv
#: Game.Levels.Group.L01_MulInv
msgid "ยง0 is a proof that for all ยง1, ยง2 (Right Inverse Axiom)."
msgstr ""

#. ยง0: `gpow_pred`
#: Game.Levels.PowGroup.L05_PowAdd
msgid "Use ยง0 for the negative step."
msgstr ""

#: Game.Levels.GroupHom.L02_HomPreservesInv
msgid "We can use a similar strategy to the last level"
msgstr ""

#: Game.Levels.Group.L09_InvInj
msgid "Inverse is Injective"
msgstr ""

#: Game
msgid "Uses Lean4.40"
msgstr ""

#. ยง0: `Int.ofNat n`
#. ยง1: `n`
#: Game.Levels.PowGroup.L01_PowNegNat
msgid "ยง0 casts a natural number ยง1 to an integer."
msgstr ""

#: Game.Levels.PowGroup.L03_PowSucc
msgid "Good! You now have a recursive rule for integer exponents too."
msgstr ""

#. ยง0: `And.intro`
#. ยง1: `h1 : P`
#. ยง2: `h2 : Q`
#. ยง3: `h : P โง Q`
#: Game.Levels.Monoid.L01_MulLeft
msgid "ยง0 is a theorem that takes two proofs ยง1 and ยง2 and returns a proof ยง3"
msgstr ""

#: Game.Levels.PowMonoid.L03_PowAdd
msgid "Awesome! You have the exponent law for addition"
msgstr ""

#. ยง0: `g`
#. ยง1: `x`
#. ยง2: `y`
#. ยง3: `g ^ x * g ^ y = g ^ (x + y)`
#: Game.Levels.PowGroup.L05_PowAdd
msgid "For any group element ยง0 and integers ยง1, ยง2,\n"
"ยง3."
msgstr ""

#. ยง0: `Int.sub_eq_add_neg`
#. ยง1: `x - y = x + (-y)`
#: Game.Levels.PowGroup.L01_PowNegNat
msgid "ยง0 is a proof that ยง1 for integers."
msgstr ""

#: Game.Levels.Monoid.L03_OneUnique
#: Game.Levels.Group.L01_MulInv
#: Game.Levels.Group.L02_CancelLeft
#: Game.Levels.Group.L03_CancelRight
#: Game.Levels.Group.L04_InvUnique
#: Game.Levels.Group.L06_CombinedInv2
#: Game.Levels.Group.L07_InvId
#: Game.Levels.Group.L08_InvInv
#: Game.Levels.Group.L09_InvInj
#: Game.Levels.GroupHom.L01_HomPreservesOne
#: Game.Levels.GroupHom.L02_HomPreservesInv
#: Game.Levels.GroupHom.L03_IdHom
#: Game.Levels.GroupHom.L04_OneHom
#: Game.Levels.GroupHom.L05_HomCompHom
#: Game.Levels.Ring.L02_NegMul
#: Game.Levels.GroupExamples.L01_Z_mod_mZ_Id
#: Game.Levels.GroupExamples.L02_Z_mod_mZ_Inv
#: Game.Levels.GroupExamples.L03_Dihedral_Id
#: Game.Levels.GroupExamples.L04_Dihedral_Inv
msgid "Congrats!"
msgstr ""

#. ยง0: `m`
#. ยง1: `x : โ`
#. ยง2: `m ^ x * m = m * m ^ x`
#: Game.Levels.PowMonoid.L06_PowCommMul
msgid "For any ยง0 in a monoid and ยง1,\n"
"ยง2."
msgstr ""

#. ยง0: `n = 0`
#: Game.Levels.PowMonoid.L02_PowSuccLeft
msgid "Start with the case ยง0."
msgstr ""

#. ยง0: `constructor`
#. ยง1: `P โ Q`
#. ยง2: `P โ Q`
#. ยง3: `P โง Q`
#. ยง4: `P`
#. ยง5: `Q`
#: Game.Levels.Monoid.L01_MulLeft
msgid "The ยง0 tactic can be used to prove goals that are inductive types with a single constructor. For example, it can be used to prove ยง1 by proving ยง2, or to prove ยง3 by splitting the goal into proving ยง4 and ยง5."
msgstr ""

#: Game.Levels.Group.L01_MulInv
msgid "We will now prove that we the inverse is a also a right multiplicative inverse. This is a bit more challenging than the previous levels, but it will be helpful to know this later on. This is one half of the \"Cancellation Rule for Groups\""
msgstr ""

#. ยง0: `mยน = m`
#: Game.Levels.PowMonoid.L01_PowOne
msgid "Weโve defined the power of an element in a monoid recursively.\n"
"In this level youโll prove the basic fact that ยง0."
msgstr ""

#: Game.Levels.Group.L08_InvInv
msgid "Inverse of an Inverse"
msgstr ""

#: Game.Levels.GroupHom.L03_IdHom
msgid "The Identity Function is a Homomorphism"
msgstr ""

#. ยง0: `m`
#. ยง1: `x`
#. ยง2: `y`
#. ยง3: `m ^ (x + y) = m ^ x * m ^ y`
#: Game.Levels.PowMonoid.L03_PowAdd
msgid "For any ยง0 in a monoid and natural numbers ยง1, ยง2, we have ยง3."
msgstr ""

#: Game.Levels.Group.L07_InvId
msgid "Inverse of the Identity"
msgstr ""

#. ยง0: `id_unique`
#: Game.Levels.Monoid.L03_OneUnique
msgid "ยง0 is a proof that there is only one identity element in a monoid"
msgstr ""

#. ยง0: `Int.induction_on`
#. ยง1: `x`
#: Game.Levels.PowGroup.L03_PowSucc
#: Game.Levels.PowGroup.L05_PowAdd
#: Game.Levels.PowGroup.L06_PowNeg
msgid "Use ยง0 on ยง1."
msgstr ""

#. ยง0: `inv_id`
#: Game.Levels.Group.L07_InvId
msgid "ยง0 is a proof that the inverse of the identity is the identity."
msgstr ""

#. ยง0: `Z_mod_mZ_inv`
#. ยง1: `Z_mod_mZ`
#. ยง2: `a`
#: Game.Levels.GroupExamples.L02_Z_mod_mZ_Inv
#: Game.Levels.GroupExamples.L04_Dihedral_Inv
msgid "ยง0 is a proof that the group ยง1 has an inverse for every element ยง2."
msgstr ""

#. ยง0: `Nat.add_zero`
#. ยง1: `n`
#. ยง2: `n + 0 = n`
#: Game.Levels.PowMonoid.L01_PowOne
#: Game.Levels.PowMonoid.L01_PowOne
#: Game.Levels.PowMonoid.L01_PowOne
msgid "ยง0 is a proof that for any natural number ยง1, ยง2."
msgstr ""

#. ยง0: `m ^ (x * y) = (m ^ x) ^ y`
#: Game.Levels.PowMonoid.L04_PowMul
msgid "Next, you will prove another standard law: ยง0."
msgstr ""

#. ยง0: `MyAlgebra.gpow_one`
#. ยง1: `g`
#. ยง2: `g ^ 1 = g`
#: Game.Levels.PowGroup.L01_PowNegNat
#: Game.Levels.PowGroup.L01_PowNegNat
msgid "ยง0 is a proof that for a group element ยง1, ยง2."
msgstr ""

#. ยง0: `m`
#. ยง1: `m ^ (n + 1) = m * m ^ n`
#: Game.Levels.PowMonoid.L02_PowSuccLeft
msgid "For any monoid element ยง0, ยง1."
msgstr ""

#: Game.Levels.GroupHom.L02_HomPreservesInv
msgid "Homomorphisms preserve inverses"
msgstr ""

#. ยง0: `f`
#. ยง1: `โ a b : G, f (a * b) = f a * f b`
#. ยง2: `f.hom`
#. ยง3: `f.hom a b : โ a b : G, f (a * b) = f a * f b`
#. ยง4: `f`
#. ยง5: `f a`
#: Game.Levels.GroupHom.L01_HomPreservesOne
msgid "Here we'll prove that a homomorphism preserves the identity element.\n"
"\n"
"  We define a homomorphism as a function ยง0 that satisfies the following property:\n"
"  ยง1\n"
"\n"
"  And we can access this property by using ยง2 where ยง3.\n"
"\n"
"  We can also use the homomorphism as a function by using ยง4 directly. Example: ยง5."
msgstr ""

#. ยง0: `MyAlgebra.oneFunction G H`
#. ยง1: `G`
#. ยง2: `H`
#. ยง3: `g : G`
#. ยง4: `1 : H`
#: Game.Levels.GroupHom.L01_HomPreservesOne
msgid "ยง0 is the trivial group homomorphism from group ยง1 to group ยง2,\n"
"mapping every element ยง3 to the identity element ยง4."
msgstr ""

#. ยง0: `have q : r := p`
#. ยง1: `q`
#. ยง2: `r`
#. ยง3: `p`
#. ยง4: `by`
#: Game.Levels.Monoid.L01_MulLeft
msgid "ยง0 will add a new hypothesis called ยง1 with type ยง2 to the local context. It will need a proof ยง3. Where you can use ยง4 to start a proof."
msgstr ""

#: Game.Levels.Ring.L02_NegMul
msgid "We've seen how the identity element of addition interacts with multiplication. Now we'll see how the additive inverse interacts with multiplication."
msgstr ""

#. ยง0: `cases`
#: Game.Levels.PowGroup.L01_PowNegNat
msgid "The ยง0 tactic performs case analysis on an inductive type."
msgstr ""

#: Game.Levels.Ring.L01_MulZero
msgid "Multiplication by Zero"
msgstr ""

#. ยง0: `exact h`
#. ยง1: `h`
#: Game.Levels.Monoid.L01_MulLeft
msgid "ยง0 will close the goal if ยง1 is a proof of the goal."
msgstr ""

#. ยง0: `x`
#. ยง1: `gpow`
#: Game.Levels.PowGroup.L04_PowPred
msgid "You can proceed by cases on ยง0 (nonnegative / negative) as in the definition of ยง1."
msgstr ""

#: Game.Levels.PowMonoid.L07_PowCommPow
msgid "Powers Commute with Powers"
msgstr ""

#. ยง0: `MyAlgebra.gpow_negSucc`
#. ยง1: `g ^ (- (n + 1)) = (g ^ (n + 1))โปยน`
#: Game.Levels.PowGroup.L01_PowNegNat
#: Game.Levels.PowGroup.L01_PowNegNat
#: Game.Levels.PowGroup.L01_PowNegNat
#: Game.Levels.PowGroup.L01_PowNegNat
#: Game.Levels.PowGroup.L01_PowNegNat
#: Game.Levels.PowGroup.L01_PowNegNat
#: Game.Levels.PowGroup.L01_PowNegNat
#: Game.Levels.PowGroup.L01_PowNegNat
#: Game.Levels.PowGroup.L01_PowNegNat
#: Game.Levels.PowGroup.L01_PowNegNat
#: Game.Levels.PowGroup.L01_PowNegNat
#: Game.Levels.PowGroup.L01_PowNegNat
#: Game.Levels.PowGroup.L01_PowNegNat
#: Game.Levels.PowGroup.L01_PowNegNat
#: Game.Levels.PowGroup.L01_PowNegNat
#: Game.Levels.PowGroup.L01_PowNegNat
#: Game.Levels.PowGroup.L01_PowNegNat
#: Game.Levels.PowGroup.L01_PowNegNat
#: Game.Levels.PowGroup.L01_PowNegNat
#: Game.Levels.PowGroup.L01_PowNegNat
#: Game.Levels.PowGroup.L01_PowNegNat
#: Game.Levels.PowGroup.L01_PowNegNat
#: Game.Levels.Ring.L02_NegMul
#: Game.Levels.GroupExamples.L01_Z_mod_mZ_Id
#: Game.Levels.GroupExamples.L01_Z_mod_mZ_Id
msgid "ยง0 is a proof that ยง1."
msgstr ""

#. ยง0: `induction' l with fst rst`
#. ยง1: `l`
#. ยง2: `fst`
#. ยง3: `rst`
#: Game.Levels.Group.L06_CombinedInv2
msgid "ยง0 is a tactic that performs induction on the list ยง1, with the first element of the list being called ยง2 and the rest of the list being called ยง3."
msgstr ""

#. ยง0: `mul_one`
#. ยง1: `m : M`
#. ยง2: `1 * m = m`
#: Game.Levels.Monoid.L01_MulLeft
#: Game.Levels.Group.L01_MulInv
msgid "ยง0 is a proof that for all ยง1, ยง2 (Left Identity Axiom)."
msgstr ""

#. ยง0: `mul_right`
#. ยง1: `m1 = m2`
#. ยง2: `m1 * m = m2 * m`
#. ยง3: `_ * m`
#: Game.Levels.Monoid.L02_MulRight
msgid "ยง0 is a proof that if ยง1, then ยง2 - based on ยง3 is a well defined function."
msgstr ""

#. ยง0: `gโปยน`
#. ยง1: `(`
#. ยง2: `g`
#: Game.Levels.Group.L02_CancelLeft
msgid "The ยง0 is bordered by ยง1 if it were ยง2 we could cancel"
msgstr ""

#: Game.Levels.GroupHom.L04_OneHom
msgid "The ๐ญ function is a Homomorphism"
msgstr ""

#. ยง0: `n`
#. ยง1: `prod_list`
#. ยง2: `G`
#. ยง3: `prod_list_inv`
#. ยง4: `G`
#. ยง5: `l = [g1, g2, g3]`
#. ยง6: `prod_list l = g1 โฌ g2 โฌ g3`
#. ยง7: `prod_list_inv l = g3โปยน โฌ g2โปยน โฌ g1โปยน`
#: Game.Levels.Group.L06_CombinedInv2
msgid "We've seen that the inverse of a product of two elements is the product of the inverses in reverse order because of the anti-commutativity of the inverse operation. What about the inverse of a product of three elements? Or four? Or n?\n"
"\n"
"We should expect it to follow the same pattern, and we can use induction to prove this. The inverse of a product of ยง0 elements is the product of the inverses in reverse order.\n"
"\n"
"To make this a bit more formal, we defined a function ยง1 that takes a list of elements of a group ยง2 and returns their product. We also define a function ยง3 that takes a list of elements of a group ยง4 and returns the product of the inverses of the elements in reverse order.\n"
"\n"
"For example, if ยง5 then ยง6 and ยง7."
msgstr ""

#. ยง0: `g^(n+1)`
#. ยง1: `g^(n-1)`
#. ยง2: `gโปยน`
#: Game.Levels.PowGroup.L04_PowPred
msgid "Dually to ยง0, we can describe ยง1 by multiplying with ยง2 on the right."
msgstr ""

#. ยง0: `mul_zero`
#. ยง1: `a * 0 = 0`
#. ยง2: `a : R`
#. ยง3: `R`
#: Game.Levels.Ring.L01_MulZero
#: Game.Levels.Ring.L01_MulZero
msgid "ยง0 is a proof that ยง1 for all ยง2 in a ring ยง3. This connects the identity element of the additive group with the multiplicative group"
msgstr ""

#. ยง0: `1 ^ x = 1`
#. ยง1: `x : โ`
#: Game.Levels.PowMonoid.L05_PowId
msgid "For any monoid, ยง0 for all ยง1."
msgstr ""

#. ยง0: `hom_preserves_inv`
#: Game.Levels.GroupHom.L02_HomPreservesInv
msgid "ยง0 is a proof that a homomorphism preserves inverses."
msgstr ""

#. ยง0: `r i`
#. ยง1: `D_n`
#. ยง2: `i`
#. ยง3: `n`
#: Game.Levels.GroupExamples.L01_Z_mod_mZ_Id
msgid "ยง0 represents a rotation element in the dihedral group ยง1, where ยง2 is an integer modulo ยง3."
msgstr ""

#. ยง0: `gpow_succ`
#: Game.Levels.PowGroup.L05_PowAdd
msgid "Use the recursive formula ยง0 and associativity."
msgstr ""

#: Game.Levels.Group.L01_MulInv
msgid "We have a similar lemma for the left inverse, can we use it here?"
msgstr ""

#. ยง0: `rfl`
#. ยง1: `X = X`
#: Game.Levels.Monoid.L01_MulLeft
msgid "ยง0 proves goals of the form ยง1."
msgstr ""

#: Game.Levels.PowGroup.L02_PowNegOne
msgid "The Inverse: gโปยน = g^(-1)"
msgstr ""

#: Game.Levels.GroupHom
msgid "Group Homomorphisms"
msgstr ""

#: Game.Levels.Group.L05_CombinedInv
msgid "Inverse of a Product"
msgstr ""

#: Game.Levels.Monoid
msgid "Monoid World"
msgstr ""

#. ยง0: `intro`
#: Game.Levels.Monoid.L01_MulLeft
msgid "Start by introducing the hypothesis with ยง0."
msgstr ""

#: Game
msgid "In this game you will learn the basics of algebra"
msgstr ""

#. ยง0: `a * 0 = 0`
#. ยง1: `a : R`
#. ยง2: `R`
#. ยง3: `0 * a = 0`
#. ยง4: `a : R`
#. ยง5: `R`
#: Game.Levels.Ring.L01_MulZero
msgid "Congrats! You've proved that ยง0 for all ยง1 in a ring ยง2. This is a very important fact about rings. And the duel of this fact is also true. ยง3 for all ยง4 in a ring ยง5. It turns out this is similar to this proof so we've just added it for you."
msgstr ""

#: Game.Levels.GroupHom.L01_HomPreservesOne
msgid "Remember that f.hom is a function that takes two arguments"
msgstr ""

#. ยง0: `g`
#: Game.Levels.Group.L02_CancelLeft
msgid "What can we do to get rid of the ยง0 on both sides? It might help to use a previous lemma."
msgstr ""

#: Game.Levels.GroupHom.L01_HomPreservesOne
msgid "We probably want to use f.hom with terms that have f 1 to match with the goal"
msgstr ""

#: Game.Levels.Group.L09_InvInj
msgid "Since the inverse of an inverse to be the original element it follows that if two elements have the same inverse, they must be equal."
msgstr ""

#: Game.Levels.GroupExamples.L03_Dihedral_Id
msgid "Dihedral Group Identity"
msgstr ""

#: Game.Levels.PowMonoid.L02_PowSuccLeft
msgid "Use the induction hypothesis and associativity."
msgstr ""

#. ยง0: `mpow`
#: Game.Levels.PowGroup.L03_PowSucc
msgid "In the nonnegative case, reduce to the natural power ยง0."
msgstr ""

#: Game.Levels.PowGroup.L07_PowSub
msgid "Subtracting Integer Exponents"
msgstr ""

#: Game.Levels.PowMonoid.L04_PowMul
msgid "Multiplying Exponents"
msgstr ""

#. ยง0: `m^(x+1)`
#: Game.Levels.PowMonoid.L06_PowCommMul
msgid "Rewrite ยง0 and use associativity plus the induction hypothesis."
msgstr ""

#: Game.Levels.PowGroup.L01_PowNegNat
msgid "Negative Natural Exponent"
msgstr ""

#: Game.Levels.PowMonoid.L05_PowId
msgid "Nice! Identity behaves as expected under exponentiation."
msgstr ""

#: Game.Levels.PowMonoid.L07_PowCommPow
msgid "Excellent work! Youโve proven a general version of the previous level - that all powers of an element commute with each other."
msgstr ""

#: Game.Levels.GroupHom.L05_HomCompHom
msgid "Composition of homomorphism is also a homomorphism"
msgstr ""

#. ยง0: `Iff.intro`
#. ยง1: `P โ Q`
#. ยง2: `P โ Q`
#. ยง3: `Q โ P`
#: Game.Levels.Monoid.L01_MulLeft
msgid "The ยง0 tactic is used to prove a goal of the form ยง1. It splits the goal into two subgoals: ยง2 and ยง3."
msgstr ""

#. ยง0: `g ^ (-n) = (g ^ n)โปยน`
#. ยง1: `n`
#: Game.Levels.PowGroup.L06_PowNeg
msgid "Youโve seen that negative naturals correspond to inverses.\n"
"Now youโll prove the full statement: ยง0 for any integer ยง1."
msgstr ""

#. ยง0: `ฮฑ`
#. ยง1: `*`
#. ยง2: `1`
#: Game.Levels.GroupHom
msgid "After creating groups, it's a good idea to define a function between them. There can be a lot of different functions between groups, but we only care about the ones that preserve the group structure (becasue they are the only interesting ones). These functions are called homomorphisms.\n"
"\n"
"  So what makes up the group structure? Well, we have a set ยง0, a binary operation ยง1, an identity element ยง2, and inverses. Therefore, we need to define a function that preserves these aspects.\n"
"\n"
"  It turns out that we only need the binary operation to be preserved. And in the next two levels we get the other two for free."
msgstr ""

#: Game.Levels.GroupHom.L02_HomPreservesInv
msgid "Here we'll see that the group homomorphism definition preserves inverses."
msgstr ""

#. ยง0: `use`
#. ยง1: `use f`
#. ยง2: `f`
#: Game.Levels.GroupHom.L05_HomCompHom
msgid "Use the ยง0 tactic with the form ยง1 where ยง2 is the function you want to use."
msgstr ""

#: Game.Levels.PowMonoid.L01_PowOne
msgid "First Power: mยน = m"
msgstr ""

#: Game.Levels.Ring.L02_NegMul
msgid "Multiplication of Negatives"
msgstr ""

#. ยง0: `g`
#. ยง1: `g ^ (-1) = gโปยน`
#: Game.Levels.PowGroup.L02_PowNegOne
msgid "For any group element ยง0, we have ยง1."
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warningsโฆ ๐ญ"
msgstr ""

#. ยง0: `rfl`
#. ยง1: `rw [id]`
#: Game.Levels.GroupHom.L03_IdHom
msgid "ยง0 automatically solves this case, but you can also use ยง1"
msgstr ""

#. ยง0: `calc`
#. ยง1: `rw`
#: Game.Levels.Monoid.L01_MulLeft
msgid "ยง0 is a way to chain equalities together. It's a bit like ยง1, but you can see the whole chain of reasoning."
msgstr ""

#. ยง0: `-(-2) = 2`
#: Game.Levels.Group.L08_InvInv
msgid "You should expect the inverse of an inverse to be the original element. Ex. ยง0 or the composition of two flips is the identity. But let's formally prove it."
msgstr ""

#. ยง0: `m1 = m2`
#. ยง1: `m * m1 = m * m2`
#. ยง2: `m`
#: Game.Levels.Monoid.L01_MulLeft
msgid "Just to get us warmed up, let's create some lemmas for multiplication. We wil use the rewrite function to create a basic proof that multiplication is a function. In other words, if ยง0, then ยง1 for any ยง2. This could be useful if you want to use calc blocks later on."
msgstr ""

#: Game.Levels.PowGroup.L05_PowAdd
msgid "Excellent! You have generalized the exponent addition law to all integers."
msgstr ""

#. ยง0: `x * (n+1) = x * n + x`
#: Game.Levels.PowGroup.L08_PowMul
msgid "Use the identity ยง0 and the addition lemma for powers."
msgstr ""

#. ยง0: `n`
#. ยง1: `cases n with | zero | succ`
#: Game.Levels.PowGroup.L01_PowNegNat
msgid "Do a case split on ยง0 using ยง1."
msgstr ""

#. ยง0: `Z_mod_mZ_id`
#. ยง1: `Z_mod_mZ`
#. ยง2: `0`
#: Game.Levels.GroupExamples.L01_Z_mod_mZ_Id
msgid "ยง0 is a proof that the identity element of the group ยง1 is ยง2."
msgstr ""

#. ยง0: `Int.induction_on`
#. ยง1: `y`
#: Game.Levels.PowGroup.L08_PowMul
msgid "Use ยง0 on ยง1 as in earlier levels."
msgstr ""

#. ยง0: `*`
#. ยง1: `mpow`
#. ยง2: `mpow_zero`
#. ยง3: `m ^ 0 = 1`
#. ยง4: `mpow_succ_right`
#. ยง5: `m ^ (n + 1) = m ^ n * m`
#. ยง6: `simp`
#: Game.Levels.PowMonoid
msgid "A monoid consists of a set M together with a binary operation (ยง0) we represent repeatedly multiplying an element by itself using ยง1 with the following definition:\n"
"\n"
"    - ยง2: ยง3\n"
"    - ยง4: ยง5\n"
"\n"
"  They've also been added to ยง6"
msgstr ""

#. ยง0: `use h`
#: Game.Levels.Monoid.L01_MulLeft
msgid "ยง0 is a tactic used to provide a proof of a type using construction."
msgstr ""

#: Game.Levels.Monoid.L02_MulRight
msgid "Don't worry it's going to get a bit more challenging (and a lot more fun)!"
msgstr ""

#: Game.Levels.Group.L07_InvId
msgid "In this section, we will prove that the inverse of the identity element is the identity element itself."
msgstr ""

#. ยง0: `Nat.add_succ`
#. ยง1: `n`
#. ยง2: `m`
#. ยง3: `n + succ m = succ (n + m)`
#: Game.Levels.PowMonoid.L01_PowOne
#: Game.Levels.PowMonoid.L01_PowOne
msgid "ยง0 is a proof that for any natural numbers ยง1 and ยง2, ยง3."
msgstr ""

#. ยง0: `gโปยน`
#. ยง1: `g`
#. ยง2: `-1`
#: Game.Levels.PowGroup.L02_PowNegOne
msgid "Now you see that the usual inverse ยง0 is just ยง1 raised to ยง2."
msgstr ""

#. ยง0: `y = 0`
#: Game.Levels.PowMonoid.L03_PowAdd
#: Game.Levels.PowMonoid.L06_PowCommMul
#: Game.Levels.PowGroup.L08_PowMul
msgid "Start with ยง0."
msgstr ""

#: Game.Levels.Group.L03_CancelRight
msgid "Cancel Right Multiplication"
msgstr ""

#. ยง0: `g`
#. ยง1: `x`
#. ยง2: `g ^ (x + 1) = (g ^ x) * g`
#: Game.Levels.PowGroup.L03_PowSucc
#: Game.Levels.PowGroup.L04_PowPred
#: Game.Levels.PowGroup.L06_PowNeg
msgid "For any group element ยง0 and integer ยง1,\n"
"ยง2."
msgstr ""

#: Game.Levels.PowGroup.L05_PowAdd
msgid "Adding Integer Exponents"
msgstr ""

#. ยง0: `m ^ (x + y) = m ^ x * m ^ y`
#: Game.Levels.PowMonoid.L03_PowAdd
msgid "Now we prove the fundamental law of exponents in a monoid:\n"
"ยง0."
msgstr ""

#. ยง0: ```
#.   inductive Dihedral (n : โ) : Type
#.     | r : ZMod n โ Dihedral n
#.     | sr : ZMod n โ Dihedral n
#.   ```
#. ยง1: `r i`
#. ยง2: `sr i`
#. ยง3: `r`
#. ยง4: `s`
#: Game.Levels.GroupExamples.L03_Dihedral_Id
msgid "We can consider n-gons and their symmetries, which form a group called the dihedral group. The dihedral group of order 2n, denoted D_n, consists of n rotations and n reflections.\n"
"\n"
"  Here is a square with its vertices labeled (1,2,3,4) and its symmetries (rotations and reflections):\n"
"\n"
"    1-----2\n"
"    |     |\n"
"    4-----3\n"
"\n"
"  Rotations:\n"
"    0ยฐ (identity)      90ยฐ                180ยฐ               270ยฐ\n"
"    1-----2            4-----1            3-----4            2-----3\n"
"    |     |            |     |            |     |            |     |\n"
"    4-----3            3-----2            2-----1            1-----4\n"
"\n"
"  Reflections:\n"
"    Vertical           Horizontal         Diagonal (\\\\)        Diagonal (/)\n"
"    2-----1            4-----3            1-----4             3-----2\n"
"    |     |            |     |            |     |             |     |\n"
"    3-----4            1-----2            2-----3             4-----1\n"
"\n"
"  Each symmetry is an element of the dihedral group Dโ.\n"
"\n"
"\n"
"  We define the dihedral group D_n as follows:\n"
"  ยง0\n"
"  The elements of D_n are either rotations (ยง1) or reflections (ยง2), where i is an integer modulo n. ยง3 stands for rotation and ยง4 stands for reflection.\n"
"\n"
"  In this level, we will prove that the identity element of the dihedral group D_n is the identity rotation, which does not change the polygon."
msgstr ""

#. ยง0: `mul_left`
#. ยง1: `m1 = m2`
#. ยง2: `m * m1 = m * m2`
#. ยง3: `m * _`
#: Game.Levels.Monoid.L01_MulLeft
msgid "ยง0 is a proof that if ยง1, then ยง2 - basically ยง3 is a function."
msgstr ""

#: Game
msgid "Algebra Game"
msgstr ""

#: Game.Levels.Group.L06_CombinedInv2
msgid "Inverse of n Products"
msgstr ""

#: Game.Levels.PowMonoid.L06_PowCommMul
msgid "Commuting a Power with its Base"
msgstr ""

#: Game.Levels.Group
msgid "Group World"
msgstr ""

#. ยง0: `inv_n_prod`
#. ยง1: `n`
#: Game.Levels.Group.L06_CombinedInv2
msgid "ยง0 is a proof that the inverse of a product of ยง1 elements is the product of the inverses in reverse order."
msgstr ""

#. ยง0: `Int.mul_sub`
#. ยง1: `gpow_sub`
#: Game.Levels.PowGroup.L08_PowMul
msgid "For the negative step, use ยง0 and your subtraction lemma ยง1."
msgstr ""

#. ยง0: `prod_list`
#. ยง1: `prod_list_inv`
#. ยง2: `rw [prod_list]`
#. ยง3: `rw [prod_list_inv]`
#: Game.Levels.Group.L06_CombinedInv2
msgid "We can use the base cases in the definition of ยง0 and ยง1 by using ยง2 and ยง3"
msgstr ""

#. ยง0: `G`
#. ยง1: `prod_list_inv`
#. ยง2: `e`
#: Game.Levels.Group.L06_CombinedInv2
msgid "Given a list of elements of a group ยง0, ยง1 computes the product of the elements in the list in reverse order, with each element inverted.\n"
"\n"
"  If the list is empty, it returns the empty product - the identity element ยง2 of the group."
msgstr ""

#. ยง0: `And.left`
#. ยง1: `And.right`
#. ยง2: `And`
#: Game.Levels.Monoid.L01_MulLeft
#: Game.Levels.Monoid.L01_MulLeft
msgid "ยง0 and ยง1 are theorems that split an ยง2 into its left and right components"
msgstr ""

#: Game.Levels.Monoid.L03_OneUnique
msgid "Only One One"
msgstr ""

#: Game.Levels.GroupHom.L01_HomPreservesOne
msgid "Homomorphisms preserve the identity"
msgstr ""

#. ยง0: `g`
#. ยง1: `n`
#. ยง2: `g ^ (-(n : โค)) = (g ^ n)โปยน`
#: Game.Levels.PowGroup.L01_PowNegNat
msgid "For a group element ยง0 and a natural number ยง1, we have\n"
"ยง2."
msgstr ""

#: Game.Levels.PowMonoid.L03_PowAdd
msgid "Adding Exponents"
msgstr ""

#. ยง0: `prod_list`
#. ยง1: `prod_list_inv`
#: Game.Levels.Group.L06_CombinedInv2
msgid "Since we're working with a generalized number of elements, it might be helpful to use induction. It also helps that the functions ยง0 and ยง1 are defined recursively."
msgstr ""

#. ยง0: `y = 0`
#: Game.Levels.PowMonoid.L04_PowMul
msgid "Start with ยง0 first."
msgstr ""

#. ยง0: `Fin.zero_add`
#. ยง1: `a`
#. ยง2: `Fin n`
#. ยง3: `0 + a = a`
#: Game.Levels.GroupExamples.L01_Z_mod_mZ_Id
msgid "ยง0 is a proof that for any element ยง1 of ยง2, ยง3."
msgstr ""

#: Game.Levels.GroupExamples.L04_Dihedral_Inv
msgid "In this level, we will prove that every element in the dihedral group has an inverse."
msgstr ""

#: Game.Levels.GroupExamples.L02_Z_mod_mZ_Inv
#: Game.Levels.GroupExamples.L04_Dihedral_Inv
msgid "Z mod mZ Inverses"
msgstr ""

#. ยง0: `i`
#. ยง1: `gโปยน`
#. ยง2: `g`
#. ยง3: `i = gโปยน`
#: Game.Levels.Group.L04_InvUnique
msgid "Similar to how there's only one identity element, there's only one inverse element. We can use a similar augment from the last level to prove this. If ยง0 and ยง1 are both inverses of ยง2, then ยง3."
msgstr ""

#. ยง0: `g`
#. ยง1: `x`
#. ยง2: `y`
#. ยง3: `g ^ (x * y) = (g ^ x) ^ y`
#: Game.Levels.PowGroup.L08_PowMul
msgid "For any group element ยง0 and integers ยง1, ยง2,\n"
"we have ยง3."
msgstr ""

#. ยง0: `*`
#. ยง1: `1 โ M`
#. ยง2: `m1, m2, m3 โ M`
#: Game.Levels.Monoid
msgid "A monoid consists of a set M together with a binary operation (ยง0) satisfying the following axioms:\n"
"  #### Identity Axiom\n"
"  There is an element ยง1 such that\n"
"\n"
"    - mul_one : โ m : M, 1 * m = m\n"
"    - one_mul : โ m : M, m * 1 = m\n"
"\n"
"  The element 1 is called the identity element of M.\n"
"\n"
"  #### Associative Law\n"
"  For all ยง2, the associative law holds:\n"
"\n"
"    - mul_assoc : โ m1 m2 m3 : M, (m1 * m2) * m3 = m1 * (m2 * m3)"
msgstr ""

#. ยง0: `Dihedral_id`
#. ยง1: `D_n`
#. ยง2: `r 0`
#: Game.Levels.GroupExamples.L03_Dihedral_Id
msgid "ยง0 is a proof that the identity element of the dihedral group ยง1 is ยง2."
msgstr ""

#. ยง0: `G`
#. ยง1: `prod_list`
#. ยง2: `e`
#: Game.Levels.Group.L06_CombinedInv2
msgid "Given a list of elements of a group ยง0, ยง1 computes their product.\n"
"\n"
"  If the list is empty, it returns the empty product - the identity element ยง2 of the group."
msgstr ""

#: Game.Levels.GroupExamples
msgid "In this world, we will explore some examples of groups. We will see how the axioms of groups apply to these examples and how they can be used to prove properties about the groups."
msgstr ""

#: Game.Levels.Group.L02_CancelLeft
msgid "Cancel Left Multiplication"
msgstr ""

#: Game.Levels.PowMonoid.L06_PowCommMul
msgid "Great!"
msgstr ""

#. ยง0: `g`
#. ยง1: `x`
#. ยง2: `y`
#. ยง3: `g ^ x * (g ^ y)โปยน = g ^ (x - y)`
#: Game.Levels.PowGroup.L07_PowSub
msgid "For any group element ยง0 and integers ยง1, ยง2, we have\n"
"ยง3."
msgstr ""

#. ยง0: `-(n+1)`
#. ยง1: `-n - 1`
#. ยง2: `gpow_pred`
#: Game.Levels.PowGroup.L06_PowNeg
msgid "Relate ยง0 to ยง1 and use ยง2."
msgstr ""

#: Game.Levels.PowGroup.L03_PowSucc
msgid "Adding 1 to an Integer Exponent"
msgstr ""

#: Game.Levels.GroupExamples.L01_Z_mod_mZ_Id
msgid "The set of integers Z = {... , โ2, โ1, 0, 1, 2, . . .} is a group if we use addition as the group law. It is an example of group with infinitely many elements.\n"
"\n"
"  What goes wrong if we try to use multiplication as the group law?\n"
"\n"
"  The set of integers modulo m (denoted Z/mZ) forms a group with addition as the group law.\n"
"\n"
"  Ex. Z/12Z = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11} is the group of integers modulo 12, which we use on clocks. If it's 11am and you add 1 hour, the clock wraps back to the start and it becomes 0pm (or 12pm).\n"
"\n"
"  In this level, we will prove that the identity element of the group Z_mod_mZ is 0."
msgstr ""

#: Game.Levels.GroupExamples
msgid "Group Examples World"
msgstr ""

#. ยง0: `-1`
#: Game.Levels.PowGroup.L02_PowNegOne
msgid "Here you show that exponent ยง0 gives the group inverse."
msgstr ""

#: Game.Levels.Ring
msgid "Ring World"
msgstr ""

#. ยง0: `*`
#. ยง1: `gpow`
#. ยง2: ```
#.   def gpow {G : Type} [Group G] (x : G) : โค โ G
#.   | Int.ofNat n => mpow x n
#.   | Int.negSucc n => mpow (xโปยน) (n+1)
#.   ```
#. ยง3: `gpow_ofNat`
#. ยง4: `g ^ โn = g ^ n`
#. ยง5: `gpow_negSucc`
#. ยง6: `g ^ (Int.negSucc n) = (gโปยน) ^ (n+1)`
#. ยง7: `gpow_zero`
#. ยง8: `g ^ (0 : โค) = 1`
#. ยง9: `gpow_one`
#. ยง10: `g ^ (1 : โค) = g`
#. ยง11: `inv_mpow`
#. ยง12: `(g ^ n)โปยน = (gโปยน) ^ n`
#. ยง13: `simp`
#: Game.Levels.PowGroup
msgid "A group consists of a set G together with a binary operation (ยง0) we represent repeatedly multiplying an element by itself using ยง1:\n"
"\n"
"  ยง2\n"
"  To make it easier to work with, we've created the following lemmas:\n"
"    - ยง3: ยง4\n"
"    - ยง5: ยง6\n"
"    - ยง7: ยง8\n"
"    - ยง9: ยง10\n"
"    - ยง11: ยง12\n"
"\n"
"  They've also been added to ยง13"
msgstr ""

#. ยง0: `apply h`
#. ยง1: `h`
#: Game.Levels.Monoid.L01_MulLeft
msgid "ยง0 will try to match the current goal against the conclusion of ยง1,"
msgstr ""

#. ยง0: `gpow_neg_mpow`
#: Game.Levels.PowGroup.L06_PowNeg
msgid "Use the case for a natural number via ยง0 and your previous lemma."
msgstr ""

#. ยง0: `Z_mod_mZ`
#. ยง1: `sub_eq_add_neg`
#. ยง2: `sub_eq_neg_add`
#. ยง3: `sub_self`
#: Game.Levels.GroupExamples.L02_Z_mod_mZ_Inv
msgid "In this level, we will prove that every element in the group ยง0 has an inverse.\n"
"\n"
"  It might be helpful to use the ยง1 and ยง2 lemmas from the Natural numbers, which relate subtraction to addition with negation. Also, ยง3 can be used to show that subtracting an element from itself gives zero."
msgstr ""

#. ยง0: `intro h`
#. ยง1: `h`
#: Game.Levels.Monoid.L01_MulLeft
msgid "ยง0 will move a hypothesis from the goal to a new hypothesis called ยง1."
msgstr ""

#: Game.Levels.Group.L05_CombinedInv
msgid "Our group has inverses of elements by definition but what about the inverse of the product of two elements? Since products of elements are elements of the group, they should have inverses too. This exposes the anti-commutativity of the inverse operation."
msgstr ""

#. ยง0: `*`
#. ยง1: `1 โ G`
#. ยง2: `g โ G`
#. ยง3: `h โ G`
#. ยง4: `h`
#. ยง5: `gโปยน`
#. ยง6: `g1, g2, g3 โ G`
#: Game.Levels.Group
msgid "A group consists of a set G together with a binary operation (ยง0) satisfying the following axioms:\n"
"\n"
"  #### Identity Axiom\n"
"  There is an element ยง1 such that\n"
"\n"
"    - mul_one : โ g : G, 1 * g = g\n"
"    - one_mul : โ g : G, g * 1 = g\n"
"\n"
"  The element 1 is called the identity element of G.\n"
"\n"
"  #### Inverse Axiom\n"
"  For every ยง2 there is an element ยง3 such that\n"
"\n"
"    - mul_inv : โ g : G, g * gโปยน = 1\n"
"    - inv_mul : โ g : G, gโปยน * g = 1\n"
"\n"
"  The element ยง4 is denoted ยง5 (written \"g\\\\inv\") and is called the inverse of g.\n"
"\n"
"  #### Associative Law\n"
"  For all ยง6, the associative law holds:\n"
"\n"
"    - mul_assoc : โ g1 g2 g3 : G, (g1 * g2) * g3 = g1 * (g2 * g3)"
msgstr ""

#. ยง0: `rw`
#. ยง1: `ยซ{h}ยป`
#: Game.Levels.Monoid.L01_MulLeft
msgid "Now, use ยง0 to rewrite the goal using the hypothesis ยง1."
msgstr ""

#. ยง0: `g ^ y`
#. ยง1: `y`
#: Game.Levels.PowGroup.L07_PowSub
msgid "We now prove the exponent law for subtraction:\n"
"multiplying by the inverse of ยง0 corresponds to subtracting ยง1 in the exponent."
msgstr ""

#. ยง0: `Int.zero_add`
#. ยง1: `a`
#. ยง2: `0 + a = a`
#: Game.Levels.GroupExamples.L01_Z_mod_mZ_Id
msgid "ยง0 is a proof that for any integer ยง1, ยง2."
msgstr ""

#: Game.Levels.Monoid.L01_MulLeft
msgid "Left Multiplication"
msgstr ""

#: Game.Levels.PowMonoid.L05_PowId
msgid "Powers of the Identity"
msgstr ""

#. ยง0: `mul a b`
#. ยง1: `a`
#. ยง2: `b`
#: Game.Levels.GroupExamples.L01_Z_mod_mZ_Id
msgid "ยง0 represents the multiplication of elements ยง1 and ยง2 in the dihedral group."
msgstr ""

#. ยง0: `g ^ (-(n : โค))`
#. ยง1: `g ^ n`
#: Game.Levels.PowGroup.L01_PowNegNat
msgid "We now move to powers with integer exponents.\n"
"In this level, youโll show that ยง0 is the inverse of ยง1."
msgstr ""

#. ยง0: `Int.induction_on`
#. ยง1: `z`
#: Game.Levels.PowGroup.L01_PowNegNat
msgid "The ยง0 tactic performs induction on an integer ยง1."
msgstr ""

#: Game.Levels.PowMonoid.L01_PowOne
msgid "Nice! You've taken the first step in using our power function on monoids."
msgstr ""

#. ยง0: `m`
#. ยง1: `x`
#. ยง2: `y`
#. ยง3: `m ^ x * m ^ y = m ^ y * m ^ x`
#: Game.Levels.PowMonoid.L07_PowCommPow
msgid "For any ยง0 in a monoid and naturals ยง1, ยง2,\n"
"ยง3."
msgstr ""

#: Game.Levels.Monoid.L01_MulLeft
msgid "Congrats on your first proof! Now let's move on to the next level."
msgstr ""

#: Game.Levels.GroupExamples.L03_Dihedral_Id
msgid "Use the definition of multiplication in the dihedral group."
msgstr ""

#: Game.Levels.PowMonoid.L04_PowMul
msgid "Well done! You have derived the law of exponents for multiplication. Can you think of any examples of this law?"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed! ๐"
msgstr ""

#. ยง0: `x - y`
#. ยง1: `sub_eq_add_neg`
#. ยง2: `gpow_add`
#. ยง3: `gpow_neg`
#: Game.Levels.PowGroup.L07_PowSub
msgid "Try rewriting ยง0 using ยง1 and then apply the addition rule ยง2 and the negation rule ยง3."
msgstr ""

#. ยง0: `Dihedral`
#: Game.Levels.GroupExamples.L04_Dihedral_Inv
msgid "What is the inverse of an element in ยง0? Dihedral elements are either rotations or reflections."
msgstr ""

#: Game.Levels.Ring.L01_MulZero
msgid "We now have a ring but how do the additive and multiplicative groups interact? The only axiom we have connecting the two is the distributivity axiom. This turns out to be enough to how the multiplicative group interacts with the additive identity."
msgstr ""

#. ยง0: `g ^ (n + 1) = g ^ n * g`
#: Game.Levels.PowGroup.L03_PowSucc
msgid "Next, you will show a recursive formula for integer exponents:\n"
"ยง0."
msgstr ""

#. ยง0: `g ^ (x * y) = (g ^ x) ^ y`
#: Game.Levels.PowGroup.L08_PowMul
msgid "Finally, we prove the multiplication law for integer exponents:\n"
"ยง0."
msgstr ""

#. ยง0: `MyAlgebra.gpow g n`
#. ยง1: `g`
#. ยง2: `n`
#: Game.Levels.PowGroup.L01_PowNegNat
msgid "ยง0 is the integer power of a group element ยง1 to the power ยง2."
msgstr ""

#. ยง0: `-1`
#. ยง1: `-(1 : โค)`
#: Game.Levels.PowGroup.L02_PowNegOne
msgid "Write ยง0 as ยง1 and then use the previous level."
msgstr ""

#. ยง0: `mpow_add`
#: Game.Levels.PowMonoid.L04_PowMul
msgid "Use the ยง0 lemma from the previous level."
msgstr ""

#. ยง0: `Z_mod_mZ`
#: Game.Levels.GroupExamples.L02_Z_mod_mZ_Inv
msgid "What is the inverse of an element in ยง0?"
msgstr ""

#. ยง0: `sub_self`
#. ยง1: `a`
#. ยง2: `a - a = 0`
#: Game.Levels.GroupExamples.L01_Z_mod_mZ_Id
msgid "ยง0 is a proof that for any element ยง1, ยง2."
msgstr ""

#: Game.Levels.PowMonoid.L03_PowAdd
msgid "Use the recursive definition of pow and the induction hypothesis."
msgstr ""

#. ยง0: `obtain โจx, y, zโฉ := h`
#. ยง1: `h`
#. ยง2: `x`
#. ยง3: `y`
#. ยง4: `z`
#. ยง5: `โจ`
#. ยง6: `\\langle`
#. ยง7: `โฉ`
#. ยง8: `\\rangle`
#: Game.Levels.Monoid.L01_MulLeft
msgid "ยง0 will destructure ยง1 into the variables ยง2, ยง3, and ยง4. This is useful for when you have a hypothesis that is a tuple or a structure. You can type ยง5 using ยง6 and ยง7 using ยง8."
msgstr ""

#: Game.Levels.PowGroup.L04_PowPred
msgid "Subtracting 1 from an Integer Exponent"
msgstr ""

#: Game.Levels.Group.L03_CancelRight
msgid "We now prove that we can cancel right multiplication - the duel of the previous level."
msgstr ""

#: Game.Levels.PowGroup.L06_PowNeg
msgid "Negating the Exponent"
msgstr ""

#: Game.Levels.PowMonoid.L02_PowSuccLeft
msgid "Succ on the Left"
msgstr ""

#. ยง0: `hom_comp_hom`
#: Game.Levels.GroupHom.L05_HomCompHom
msgid "ยง0 is a proof that composition of homomorphisms is also a homomorphism."
msgstr ""

#. ยง0: `inv_mul`
#. ยง1: `g : G`
#. ยง2: `gโปยน * g = 1`
#: Game.Levels.Group.L01_MulInv
#: Game.Levels.PowGroup.L01_PowNegNat
msgid "ยง0 is a proof that for all ยง1, ยง2 (Left Inverse Axiom)."
msgstr ""

#. ยง0: `And.intro`
#: Game.Levels.Group.L05_CombinedInv
msgid "You can use ยง0 to break down the goal into two goals."
msgstr ""

#. ยง0: `inv_inv`
#: Game.Levels.Group.L08_InvInv
msgid "ยง0 is a proof that the inverse of an inverse is the original element."
msgstr ""

#. ยง0: `h : X = Y`
#. ยง1: `X`
#. ยง2: `nth_rewrite 3 [h]`
#. ยง3: `X`
#. ยง4: `Y`
#: Game.Levels.Monoid.L01_MulLeft
#: Game.Levels.Monoid.L01_MulLeft
msgid "If ยง0 and there are several ยง1s in the goal, then ยง2 will just change the third ยง3 to a ยง4."
msgstr ""

#. ยง0: `gโปยน`
#: Game.Levels.PowGroup.L04_PowPred
msgid "Great! You can move down in the exponent by multiplying on the right with ยง0."
msgstr ""

#: Game.Levels.Group.L04_InvUnique
msgid "Unique Inverse"
msgstr ""

#: Game.Levels.PowGroup.L06_PowNeg
msgid "Nice! Youโve fully connected negative integer exponents with group inverses."
msgstr ""

#: Game.Levels.PowGroup.L08_PowMul
msgid "Multiplying Integer Exponents"
msgstr ""

#. ยง0: `cases' h with h1 h2 ... hn`
#. ยง1: `h`
#. ยง2: `h1 h2 ... hn`
#: Game.Levels.Monoid.L01_MulLeft
msgid "ยง0 is a tactic that splits ยง1 into cases and adds them as hypotheses ยง2"
msgstr ""

#. ยง0: `gpow_negSucc`
#. ยง1: `mpow_succ_right`
#: Game.Levels.PowGroup.L03_PowSucc
msgid "In the negative case, use ยง0, ยง1, and cancellation."
msgstr ""

#. ยง0: `simp`
#: Game.Levels.Monoid.L01_MulLeft
msgid "ยง0 is a magic tactic that tries lots of different things to simplify your goal."
msgstr ""

#. ยง0: `g ^ x * g ^ y = g ^ (x + y)`
#. ยง1: `x`
#. ยง2: `y`
#: Game.Levels.PowGroup.L05_PowAdd
msgid "Now youโll prove the group version of the exponent-addition law:\n"
"ยง0 for all integers ยง1, ยง2."
msgstr ""

#. ยง0: `1^0`
#: Game.Levels.PowMonoid.L05_PowId
msgid "What is ยง0 by definition?"
msgstr ""

#. ยง0: `m`
#: Game.Levels.PowMonoid.L02_PowSuccLeft
msgid "Good! Youโve learned to move the extra ยง0 to the left using induction and associativity."
msgstr ""

#: Game.Levels.PowMonoid
msgid "Monoid Power World"
msgstr ""

#. ยง0: `x - y = x + (-y)`
#: Game.Levels.PowGroup.L07_PowSub
msgid "Recall that ยง0."
msgstr ""

#. ยง0: `hom_trival`
#: Game.Levels.GroupHom.L04_OneHom
msgid "ยง0 is a proof that the ๐ญ function is a homomorphism."
msgstr ""
